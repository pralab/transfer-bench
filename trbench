#!/usr/bin/env python3
r"""Command line interface for running and displaying results of transfer attacks."""

import logging
from argparse import ArgumentParser
from typing import Optional

import wandb
from benchmark_tools.config import DEFAULT_DEVICE
from benchmark_tools.run_helpers import collect_runs, run_single_scenario
from pandas import DataFrame

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format=">>> [%(levelname)s] %(asctime)s  \n%(message)s\n<<<",
)
logger = logging.getLogger(__name__)


def parse_args() -> None:
    r"""Parse command line arguments."""
    parser = ArgumentParser(
        description="Command line tool for managing benchamrks of the transfer attack."
    )
    subparser = parser.add_subparsers(dest="command", required=True)
    # Subparsers for getting informations on the runs
    parser_info = subparser.add_parser(
        "display", help="Display informations on the runs."
    )
    parser_info.add_argument(
        dest="status",
        nargs="?",
        choices=["all", "running", "finished", "crashed", "failed", "missing"],
        default="all",
        type=str,
        help="Information to be displyed",
    )
    parser_info.add_argument("--query", type=str, help="Query to filter displayed runs")
    # Subparser for running the experiments
    parser_run = subparser.add_parser(
        "run",
        help="Run a job from the list of availables.",
    )
    parser_run.add_argument(
        dest="run_id", nargs="?", type=str, help="ID of the run to be executed."
    )
    parser_run.add_argument(
        "--query", type=str, help="Lunch the runs selecting them by query"
    )
    parser_run.add_argument("--next", type=str, help="Next available run.")
    parser_run.add_argument(
        "--device", type=str, default=DEFAULT_DEVICE, help="Device to be used."
    )
    parser_run.add_argument(
        "--batch-size", type=int, default=100, help="Batch size to be used."
    )
    parser_run.add_argument(
        "--ignore-finished",
        action="store_true",
        default=False,
        help="Ignore finished runs and run the job anyway.",
    )

    return parser.parse_args()


def get_filtered_runs(status: str = "all", query: Optional[str] = None) -> DataFrame:
    r"""Retrieve and filter run information based on the specified criteria."""
    runs = collect_runs()
    if status != "all":
        runs = runs[runs["status"] == status]
    if query is not None:
        runs = runs.query(query)
    return runs


def run_batch(run_ids: list[str], batch_size: int, device: str) -> None:
    r"""Run a single scenario."""
    # check if the run_id is missing
    for run_id in run_ids:
        run_single_scenario(run_id, batch_size, device)


if __name__ == "__main__":
    import sys

    # sys.argv.append("display")
    # sys.argv.append("all")
    # sys.argv.append("run")
    # sys.argv.append("c432f")
    # sys.argv.append("--device")
    # sys.argv.append("cpu")
    # Login to Weights & Biases-
    wandb.login()
    # Parse the command line arguments
    args = parse_args()
    # Get the command line arguments
    command = args.command
    if command == "display":
        # Get the information on the runs
        runs = get_filtered_runs(
            status=args.status,
            query=args.query,
        )
        # Display the runs
        logger.info(runs.to_markdown(index=False))
    elif command == "run":
        if args.run_id is not None:
            run_single_scenario(args.run_id, args.batch_size, args.device)
        elif args.query is not None:
            safe_query = args.query + " and available == True"
            if not args.ignore_finished:
                safe_query += ' and status in ["missing", "failed", "crashed"]'
            df_runs = get_filtered_runs(query=safe_query)
            logger.info(
                f"Processing runs: \n {df_runs.to_markdown(index=False)}"  # noqa: G004
            )
            for run_id in df_runs.id:
                try:
                    run_single_scenario(run_id, args.batch_size, args.device)
                except (  # noqa: PERF203
                    ValueError,
                    RuntimeError,
                ) as e:  # Replace with specific exceptions
                    logger.exception(f"Error while processing run {run_id}\n {e}")  # noqa: G004
                    # Ask the user if they want to continue
                    if input("Do you want to continue? (y/n)").lower() not in ["", "y"]:
                        break

        elif args.next is not None:
            logger.warning(
                "The --next option is deprecated and will be removed in the future."
            )
            # Get the next available run
            df_runs = get_filtered_runs("missing")
            if df_runs.empty:
                msg = "No runs available."
                raise ValueError(msg)
            # Get the next available run
            run_id = df_runs.iloc[0].id
            run_single_scenario(run_id, args.batch_size, args.device)
