#!/usr/bin/env python3
r"""Command line interface for running and displaying results of transfer attacks."""

import logging
from argparse import ArgumentParser
from typing import Optional

import wandb
from benchmark.config import DEFAULT_DEVICE
from benchmark.run_helpers import collect_runs, run_single_scenario
from pandas import DataFrame

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format=">>> [%(levelname)s] %(asctime)s  \n%(message)s\n<<<",
)
logger = logging.getLogger(__name__)


def parse_args() -> None:
    r"""Parse command line arguments."""
    parser = ArgumentParser(
        description="Command line tool for managing benchamrks of the transfer attack."
    )
    subparser = parser.add_subparsers(dest="command", required=True)
    # Subparsers for getting informations on the runs
    parser_info = subparser.add_parser(
        "display", help="Display informations on the runs."
    )
    parser_info.add_argument(
        dest="status",
        nargs="?",
        choices=["all", "running", "finished", "failed", "missing"],
        default="all",
        type=str,
        help="Information to be displyed",
    )
    parser_info.add_argument("--query", type=str, help="Query to filter displayed runs")
    # Subparser for running the experiments
    parser_run = subparser.add_parser(
        "run",
        help="Run a job from the list of availables.",
    )
    parser_run.add_argument(
        dest="run-id", type=str, help="ID of the run to be executed."
    )
    parser_run.add_argument("--next", type=str, help="Next available run.")
    parser_run.add_argument(
        "--force", action="store_true", help="Force the run to be executed."
    )
    parser_run.add_argument(
        "--device", type=str, default=DEFAULT_DEVICE, help="Device to be used."
    )
    parser_run.add_argument(
        "--batch-size", type=int, default=10, help="Batch size to be used."
    )

    return parser.parse_args()


def get_filtered_runs(status: str = "all", query: Optional[str] = None) -> DataFrame:
    r"""Retrieve and filter run information based on the specified criteria."""
    runs = collect_runs()
    if status != "all":
        runs = runs[runs["status"] == status.capitalize()]
    if query is not None:
        runs = runs.query(query)
    return runs


def run_batch(run_ids: list[str], batch_size: int, device: str) -> None:
    r"""Run a single scenario."""
    # check if the run_id is missing
    runs = collect_runs()
    for run_id in run_ids:
        run_single_scenario(run_id, batch_size, device)


if __name__ == "__main__":
    # Login to Weights & Biases
    wandb.login()
    # Parse the command line arguments
    args = parse_args()
    # Get the command line arguments
    command = args.command
    if command == "display":
        # Get the information on the runs
        runs = get_filtered_runs(
            status=args.status,
            query=args.query,
        )
        # Display the runs
        logging.info(runs.to_markdown(index=False))
    elif command == "run":
        # Run a single scenario
        run_id = args.run_id
        batch_size = args.batch_size
        device = args.device
        run_single_scenario(run_id, batch_size, device)
    else:
        msg = f"Unknown command {command}"
        raise ValueError(msg)
